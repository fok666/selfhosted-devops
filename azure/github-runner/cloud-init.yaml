#cloud-config

package_update: true
package_upgrade: true

packages:
  - docker.io
  - curl
  - jq

write_files:
  - path: /opt/stop.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      echo "Stopping GitHub runners..."
      RUNNER_CONTAINERS=$(docker ps --filter "name=github-runner-" --format "{{.Names}}" | sort)
      if [ -z "$RUNNER_CONTAINERS" ]; then
        echo "No running GitHub runner containers found."
        exit 0
      fi
      for CONTAINER_NAME in $RUNNER_CONTAINERS; do
        echo "Stopping $CONTAINER_NAME..."
        docker stop -t 30 "$CONTAINER_NAME" > /dev/null 2>&1 || true
        docker rm "$CONTAINER_NAME" > /dev/null 2>&1 || true
        echo "  $CONTAINER_NAME stopped and removed"
      done
      echo "All GitHub runners stopped successfully!"

  - path: /opt/vmss_monitor.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      METADATA_ENDPOINT='http://169.254.169.254/metadata/scheduledevents?api-version=2020-07-01'
      EVENTS_FILE='/tmp/scheduledevents.json'
      STOP_SCRIPT='/opt/stop.sh'
      echo "Checking for VMSS scheduled events..."
      curl -s "$METADATA_ENDPOINT" -H 'Metadata: true' > "$EVENTS_FILE"
      if grep -q "Terminate" "$EVENTS_FILE"; then
        echo "Terminate event detected! Initiating graceful shutdown..."
        if [ -x "$STOP_SCRIPT" ]; then
          echo "Executing stop script: $STOP_SCRIPT"
          "$STOP_SCRIPT"
        else
          echo "Warning: Stop script not found or not executable: $STOP_SCRIPT"
        fi
        EventId=$(jq -r '.Events[] | select(.EventType == "Terminate") | .EventId' "$EVENTS_FILE")
        if [ -n "$EventId" ]; then
          echo "Acknowledging event: $EventId"
          curl -s -X POST "$METADATA_ENDPOINT" \
            -H 'Metadata: true' \
            -d "{\"StartRequests\": [{\"EventId\": \"$${EventId}\"}]}"
          echo "Event acknowledged successfully"
        fi
      else
        echo "No termination events scheduled"
      fi

  - path: /opt/run-github-runners.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      GITHUB_URL="${github_url}"
      GITHUB_TOKEN="${github_token}"
      RUNNER_LABELS="${runner_labels}"
      RUNNER_COUNT="${runner_count}"
      DOCKER_IMAGE="${runner_docker_image}"
      
      # Production Features Configuration
      ENABLE_CACHE="${enable_distributed_cache}"
      CACHE_STORAGE_ACCOUNT="${cache_storage_account_name}"
      CACHE_CONTAINER="${cache_storage_container_name}"
      CACHE_STORAGE_KEY="${cache_storage_account_key}"
      CACHE_SHARED="${cache_shared}"
      ENABLE_MONITORING="${enable_runner_monitoring}"
      METRICS_PORT="${metrics_port}"
      
      # Auto-detect runner count based on CPU count if runner_count is 0
      if [ "$RUNNER_COUNT" = "0" ]; then
        CPU_COUNT=$(nproc)
        # Scale runner count based on available CPUs:
        # 1-2 CPUs: 1 runner
        # 3-4 CPUs: 2 runners
        # 5-8 CPUs: 3 runners
        # 9-16 CPUs: 4 runners
        # 17+ CPUs: CPU_COUNT / 4 (rounded up)
        if [ $CPU_COUNT -le 2 ]; then
          RUNNER_COUNT=1
        elif [ $CPU_COUNT -le 4 ]; then
          RUNNER_COUNT=2
        elif [ $CPU_COUNT -le 8 ]; then
          RUNNER_COUNT=3
        elif [ $CPU_COUNT -le 16 ]; then
          RUNNER_COUNT=4
        else
          RUNNER_COUNT=$(( (CPU_COUNT + 3) / 4 ))
        fi
        echo "Auto-detected $CPU_COUNT CPUs, will run $RUNNER_COUNT runners"
      fi
      
      # Calculate CPU limit per runner
      CPU_COUNT=$(nproc)
      MAX_CPU=$((CPU_COUNT / RUNNER_COUNT))
      [ $MAX_CPU -lt 1 ] && MAX_CPU=1
      
      echo "Starting $RUNNER_COUNT GitHub runner(s)..."
      
      for R in $(seq 1 $RUNNER_COUNT); do
        RUNNER_NAME="runner-$(hostname)-$R"
        WORK_DIR="/mnt/runner$R/_work"
        CONTAINER_NAME="github-runner-$R"
        
        mkdir -p "$WORK_DIR"
        
        echo "Starting runner $R/$RUNNER_COUNT: $RUNNER_NAME"
        
        if docker ps -a --format '{{.Names}}' | grep -q "^$${CONTAINER_NAME}$"; then
          echo "  Removing existing container: $CONTAINER_NAME"
          docker rm -f "$CONTAINER_NAME" > /dev/null 2>&1 || true
        fi
        
        # Build docker run command safely using an array
        DOCKER_ARGS=(
          --privileged --tty --detach --cpus="$${MAX_CPU}"
          -e GITHUB_URL="$GITHUB_URL"
          -e GITHUB_TOKEN="$GITHUB_TOKEN"
          -e RUNNER_NAME="$RUNNER_NAME"
          -e RUNNER_LABELS="$RUNNER_LABELS"
          -e RUNNER_WORK_DIRECTORY="/_work"
        )
        
        # Add cache configuration if enabled
        if [ "$ENABLE_CACHE" = "true" ]; then
          echo "  Enabling Azure Blob Storage cache"
          DOCKER_ARGS+=(-e "ACTIONS_CACHE_URL=https://$${CACHE_STORAGE_ACCOUNT}.blob.core.windows.net/$${CACHE_CONTAINER}")
          DOCKER_ARGS+=(-e "ACTIONS_RUNTIME_TOKEN=$${CACHE_STORAGE_KEY}")
        fi
        
        # Add monitoring configuration if enabled
        if [ "$ENABLE_MONITORING" = "true" ]; then
          echo "  Enabling metrics on port $METRICS_PORT"
          DOCKER_ARGS+=(-p "$METRICS_PORT:$METRICS_PORT")
        fi
        
        DOCKER_ARGS+=(
          -v /var/run/docker.sock:/var/run/docker.sock
          -v "$WORK_DIR":/_work
          --restart unless-stopped
          --name "$CONTAINER_NAME"
          "$DOCKER_IMAGE"
        )
        
        # Execute docker run
        docker run "$${DOCKER_ARGS[@]}"
        
        echo "  Container $CONTAINER_NAME started successfully"
      done
      
      echo "All runners started successfully!"
  
  - path: /opt/configure-logging.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      ENABLE_LOGGING="${enable_centralized_logging}"
      WORKSPACE_ID="${log_analytics_workspace_id}"
      WORKSPACE_KEY="${log_analytics_workspace_key}"
      
      if [ "$ENABLE_LOGGING" != "true" ]; then
        echo "Centralized logging is disabled"
        exit 0
      fi
      
      echo "Configuring Azure Log Analytics integration..."
      
      # Download and install OMS agent
      wget https://raw.githubusercontent.com/Microsoft/OMS-Agent-for-Linux/master/installer/scripts/onboard_agent.sh
      chmod +x onboard_agent.sh
      
      # Extract workspace ID from full resource ID if needed
      if [[ "$WORKSPACE_ID" == /subscriptions/* ]]; then
        WORKSPACE_ID=$(basename "$WORKSPACE_ID")
      fi
      
      # Install and onboard the agent
      ./onboard_agent.sh -w "$WORKSPACE_ID" -s "$WORKSPACE_KEY" -d opinsights.azure.com
      
      # Configure custom log collection for runner logs
      cat > /etc/opt/microsoft/omsagent/$WORKSPACE_ID/conf/omsagent.d/github-runner.conf << 'LOGEOF'
<source>
  type tail
  path /var/log/github-runner-init.log
  pos_file /var/opt/microsoft/omsagent/state/github-runner-init.pos
  tag oms.github.runner.init
  format none
</source>

<source>
  type tail
  path /var/log/vmss_monitor.log
  pos_file /var/opt/microsoft/omsagent/state/vmss-monitor.pos
  tag oms.github.runner.monitor
  format none
</source>
LOGEOF
      
      # Restart OMS agent
      /opt/microsoft/omsagent/bin/service_control restart "$WORKSPACE_ID"
      
      echo "Azure Log Analytics configured successfully"

runcmd:
  # Start and enable Docker
  - systemctl start docker
  - systemctl enable docker
  
  # Add ubuntu user to docker group
  - usermod -aG docker ubuntu
  
  # Configure centralized logging if enabled
  - /opt/configure-logging.sh >> /var/log/logging-setup.log 2>&1
  
  # Set up VMSS monitoring cron job
  - (crontab -l 2>/dev/null; echo "* * * * * /opt/vmss_monitor.sh >> /var/log/vmss_monitor.log 2>&1") | crontab -
  
  # Start GitHub runners
  - sleep 10
  - /opt/run-github-runners.sh >> /var/log/github-runner-init.log 2>&1

final_message: "GitHub Runner VM is ready!"
